{"version":3,"file":"jsonLogic.min.js","sources":["../src/operations/arithmetic/add.js","../src/operations/arithmetic/multiply.js","../src/operations/array/merge.js","../src/createJsonLogic.js","../src/index.js","../src/visitors/array/filter.js","../src/visitors/array/map.js","../src/visitors/array/reduce.js","../src/helpers/usesData.js","../src/helpers/arrayUnique.js"],"sourcesContent":["function add(...args) {\n  return args.reduce(function(a, b) {\n    return parseFloat(a, 10) + parseFloat(b, 10);\n  }, 0);\n}\n\nadd.code = '+';\n\nexport default add;\n","function multiply(...args) {\n  return args.reduce(function(a, b) {\n    return parseFloat(a, 10) * parseFloat(b, 10);\n  }, 1);\n}\n\nmultiply.code = '*';\n\nexport default multiply;\n","function merge(...args) {\n  return args.reduce(function(a, b) {\n    return a.concat(b);\n  }, []);\n}\n\nexport default merge;\n","import isArray from './helpers/isArray';\nimport isLogic from './helpers/isLogic';\nimport getOperator from './helpers/getOperator';\n\nfunction createJsonLogic(_operations, _visitors) {\n  const operations = {};\n  const visitors = {};\n\n  if (_operations) {\n    Object.keys(_operations).forEach(function(name) {\n      const operation = _operations[name];\n\n      addOperation(operation.code || name, operation);\n    });\n  }\n\n  if (_visitors) {\n    Object.keys(_visitors).forEach(function(name) {\n      const visitor = _visitors[name];\n\n      addVisitor(visitor.code || name, visitor);\n    });\n  }\n\n  function addOperation(name, code) {\n    operations[name] = code;\n  }\n\n  function removeOperation(name) {\n    delete operations[name];\n  }\n\n  function addVisitor(name, code) {\n    if (isArray(name)) {\n      name.forEach(key => addVisitor(key, code));\n      return;\n    }\n\n    visitors[name] = code;\n  }\n\n  function removeVisitor(name) {\n    if (isArray(name)) {\n      name.forEach(removeVisitor);\n      return;\n    }\n\n    delete visitors[name];\n  }\n\n  function apply(logic, data = {}) {\n    // Does this array contain logic? Only one way to find out.\n    if (isArray(logic)) {\n      return logic.map(function(l) {\n        return apply(l, data);\n      });\n    }\n    // You've recursed to a primitive, stop!\n    if (!isLogic(logic)) {\n      return logic;\n    }\n\n    const op = getOperator(logic);\n    let values = logic[op];\n    let i;\n\n    // easy syntax for unary operators, like {\"var\" : \"x\"} instead of strict {\"var\" : [\"x\"]}\n    if (!isArray(values)) {\n      values = [values];\n    }\n\n    // apply matching visitors first\n    if (typeof visitors[op] === 'function') {\n      return visitors[op](apply, data, values);\n    }\n\n    // Everyone else gets immediate depth-first recursion\n    values = values.map(function(val) {\n      return apply(val, data);\n    });\n\n    // The operation is called with \"data\" bound to its \"this\" and \"values\" passed as arguments.\n    // Structured commands like % or > can name formal arguments while flexible commands (like missing or merge) can operate on the pseudo-array arguments\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\n    const operator = operations[op];\n    if (typeof operator === 'function') {\n      if (operator.withApply) {\n        values.unshift(apply);\n      }\n\n      return operator.apply(data, values);\n    }\n    if (op.indexOf('.') > 0) {\n      // Contains a dot, and not in the 0th position\n      const sub_ops = String(op).split('.');\n      let operation = operations;\n      for (i = 0; i < sub_ops.length; i++) {\n        // Descending into operations\n        operation = operation[sub_ops[i]];\n        if (operation === undefined) {\n          throw new Error(\n            `Unrecognized operation ${op} (failed at ${sub_ops\n              .slice(0, i + 1)\n              .join('.')})`\n          );\n        }\n      }\n\n      return operation.apply(data, values);\n    }\n\n    throw new Error(`Unrecognized operation ${op}`);\n  }\n\n  return {\n    apply,\n    add_operation: addOperation,\n    rm_operation: removeOperation,\n    add_visitor: addVisitor,\n    rm_visitor: removeVisitor,\n  };\n}\n\nexport default createJsonLogic;\n","import createJsonLogic from './createJsonLogic';\nimport * as operations from './operations';\nimport * as visitors from './visitors';\nimport isLogic from './helpers/isLogic';\nimport truthy from './helpers/truthy';\nimport getOperator from './helpers/getOperator';\nimport getValues from './helpers/getValues';\nimport usesData from './helpers/usesData';\nimport ruleLike from './helpers/ruleLike';\n\nconst jsonLogic = createJsonLogic(operations, visitors);\n\n// restore original public API\njsonLogic.is_logic = isLogic;\njsonLogic.truthy = truthy;\njsonLogic.get_operator = getOperator;\njsonLogic.get_values = getValues;\njsonLogic.uses_data = usesData;\njsonLogic.rule_like = ruleLike;\n\nexport default jsonLogic;\n","import isArray from '../../helpers/isArray';\nimport truthy from '../../helpers/truthy';\n\nfunction filter(apply, data, values) {\n  const scopedData = apply(values[0], data);\n  const scopedLogic = values[1];\n\n  if (!isArray(scopedData)) {\n    return [];\n  }\n  // Return only the elements from the array in the first argument,\n  // that return truthy when passed to the logic in the second argument.\n  // For parity with JavaScript, reindex the returned array\n  return scopedData.filter(function(datum) {\n    return truthy(apply(scopedLogic, datum));\n  });\n}\n\nexport default filter;\n","import isArray from '../../helpers/isArray';\n\nfunction map(apply, data, values) {\n  const scopedData = apply(values[0], data);\n  const scopedLogic = values[1];\n\n  if (!isArray(scopedData)) {\n    return [];\n  }\n\n  return scopedData.map(function(datum) {\n    return apply(scopedLogic, datum);\n  });\n}\n\nexport default map;\n","import isArray from '../../helpers/isArray';\n\nfunction reduce(apply, data, values) {\n  const scopedData = apply(values[0], data);\n  const scopedLogic = values[1];\n  const initial = typeof values[2] !== 'undefined' ? values[2] : null;\n\n  if (!isArray(scopedData)) {\n    return initial;\n  }\n\n  return scopedData.reduce(function(accumulator, current) {\n    return apply(scopedLogic, { current, accumulator });\n  }, initial);\n}\n\nexport default reduce;\n","import isArray from './isArray';\nimport isLogic from './isLogic';\nimport getOperator from './getOperator';\nimport arrayUnique from './arrayUnique';\n\nfunction usesData(logic) {\n  const collection = [];\n\n  if (isLogic(logic)) {\n    const op = getOperator(logic);\n    let values = logic[op];\n\n    if (!isArray(values)) {\n      values = [values];\n    }\n\n    if (op === 'var') {\n      // This doesn't cover the case where the arg to var is itself a rule.\n      collection.push(values[0]);\n    } else {\n      // Recursion!\n      values.forEach(function(val) {\n        collection.push(...usesData(val));\n      });\n    }\n  }\n\n  return arrayUnique(collection);\n}\n\nexport default usesData;\n","/**\n * Return an array that contains no duplicates (original not modified)\n * @param  {array} array   Original reference array\n * @return {array}         New array with no duplicates\n */\nfunction arrayUnique(array) {\n  const a = [];\n  for (let i = 0, l = array.length; i < l; i++) {\n    if (a.indexOf(array[i]) === -1) {\n      a.push(array[i]);\n    }\n  }\n  return a;\n}\n\nexport default arrayUnique;\n"],"names":["createJsonLogic","arrayUnique"],"mappings":"69CACqB,CAAA,uNCAA,CAAA,08BCAA,CAAA,wvBCGrB,CAAA,kFA8BmB,CAAA,qEAzBkB,CAAA,mEAQF,CAAA,mJAoCZ,CAAA,uIAwBC,CAAA,igBCnENA,CAAAA,sNCGS,CAAA,iGCHH,CAAA,sLCCG,CAAA,ydCUN,CAAA,8CChBrB,CAAA,4FDsBSC,CAAAA"}